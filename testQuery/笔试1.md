## 1 如何理解Java中的装箱与拆箱
在Java中，装箱（boxing）和拆箱（unboxing）是两个常用的操作，它们用于将基本数据类型和其对应的对象类型进行转换。

装箱是将基本数据类型转换为对应的包装器类型的操作。例如，将int类型的变量i装箱为Integer类型的对象iBoxed，可以使用如下语句：
```java
int i = 10; 
Integer iBoxed = Integer.valueOf(i);
```
拆箱是将包装器类型的对象转换为对应的基本数据类型的操作。例如，将Integer类型的对象iBoxed拆箱为int类型的变量i，可以使用如下语句：
```java
Integer iBoxed = Integer.valueOf(10); 
int i = iBoxed.intValue();
```
在Java中，这些操作通常用于集合类型（如List、Set和Map）中存储基本数据类型。例如，将int类型的变量i存储到ArrayList中，
```java
int i = 10; 
ArrayList<Integer> list = new ArrayList<Integer>(); 
list.add(i); // 自动装箱
```
Java中的装箱和拆箱操作是由编译器自动完成的，程序员在编写代码时通常不需要显式地调用它们。但是，了解这些操作可以帮助程序员更好地理解Java中的数据类型和对象之间的转换关系。

## 2 Java有哪几种数据类型

Java中有八种基本数据类型，分别为：

1. byte：byte数据类型是8位、有符号的，以二进制补码表示的整数。最小值是-128（-2^7）；最大值是127（2^7-1）；默认值是0。
2. short：short数据类型是16位、有符号的以二进制补码表示的整数。最小值是-32768（-2^15）；最大值是32767（2^15 - 1）。
3. int：int数据类型是32位、有符号的以二进制补码表示的整数。最小值是-2147483648（-2^31）；最大值是2147483647（2^31 - 1）。
4. long：long数据类型是64位、有符号的以二进制补码表示的整数。最小值是-9223372036854775808（-2^63）；最大值是9223372036854775807（2^63 - 1）。
5. float：float数据类型是32位、有符号的以IEEE 754二进制浮点表示法表示的实数。最小值是1.4023E-45；最大值是3.4028235E38。
6. double：double数据类型是64位、有符号的以IEEE 754二进制浮点表示法表示的实数。最小值是4.9E-324；最大值是1.8E308。
7. char：char数据类型是16位、无符号的以UTF-16编码表示的字符。最小值是\u0000（Unicode编码中的前导零）；最大值是\uFFFF（Unicode编码中的代理对之一）。
8. boolean：boolean数据类型只有两个值，分别为true和false。

这些基本数据类型是Java编程语言的核心，它们在内存中占用不同大小的存储空间，并且具有特定的范围和用途。在实际编程中，根据需要选择适当的数据类型来确保程序的效率和准确性。

## 3 VM、JRE和JDK的关系

JVM、JRE和JDK是Java开发中的三个重要概念，它们之间的关系如下：

1. JDK（Java Development Kit）是Java开发工具包，其中包括编译工具（javac.exe）和打包工具（jar.exe）等，同时也包括JRE。JDK是整个Java的核心所在，是开发和运行Java应用程序的必需工具。
2. JRE（Java Runtime Environment）是Java运行时环境，它包含Java虚拟机（JVM）和Java基础类库等运行Java程序所需要的必要组件。JRE是在JDK的基础上安装的，单独安装JRE只能运行Java程序，不能进行开发和调试等工作。
3. JVM（Java Virtual Machine）是Java虚拟机，它是JRE的一部分，负责将Java字节码转换为机器指令并执行。JVM是Java跨平台的关键，它能够将Java代码编译成与平台无关的字节码，然后在任何安装了JRE的计算机上运行。

总结来说，JDK包含了JRE和编译工具等，JRE只是JDK的一部分，而JVM又是JRE的一部分。它们之间层层递进，构成了Java开发的基础。

## 4 Switch支持的数据类型？

Switch支持的数据类型有：

1. 基本数据类型：byte、short、char、int
2. 包装数据类型：Byte、Short、Character、Integer
3. 枚举类型：Enum
4. 字符串类型：String（JDK1.7以后开始支持）

## 5 为什么float=3.4报错

在Java中，浮点数类型有两种：float和double。float是单精度浮点数，其精度为6到7位有效数字，双精度浮点数使用double类型。

当你在Java中将一个 float变量赋值为3.4时，编译器会发出错误提示，因为3.4没有精确的浮点表示法。相反，应该使用double类型的变量来存储这个小数字。

下面是一个正确的Java代码示例，使用double类型来存储3.4：
```java
double myDouble = 3.4;
```
请注意，虽然在代码中声明变量时，可以使用关键字 `float` 来声明一个单精度浮点数变量，但是在赋值时，必须使用双精度浮点数（即 `double`）。

## 6 final 有什么用？

1. 修饰类：表示类不能被继承。
2. 修饰方法：表示方法不可被子类覆盖，但是可以重载。
3. 修饰变量：表示变量一旦被赋值就不可以更改它的值。

## 7 String有哪些特性

1. 不可变性：一旦创建，String对象的值无法修改。这意味着任何试图修改字符串的尝试都会创建一个新的字符串对象。
2. 线程安全：由于String对象的不可变性，因此在多线程环境中使用String时不需要担心线程安全问题。
3. 序列化：String实现了Serializable接口，因此可以序列化并将其保存在磁盘上或通过网络传输。
4. 比较：String实现了Comparable接口，因此可以使用比较运算符进行比较。
5. 字符串常量池：当使用字面量的方式给一个字符串赋值时，字符串值会被声明在字符串常量池中。如果字符串常量池中已经存在相同的字符串，则新字符串值将指向现有的字符串值。这可以避免重复创建相同的字符串对象，从而节省内存空间。
6. 字符数组：String内部定义了一个final char[]用于存储字符串数据。这意味着字符串对象的字符数组在创建后不能被修改。

## 8 Stringbuffer和 Stringbuilder有什么不同？

Stringbuffer和Stringbuilder是Java中两个用于处理字符串的类，它们的主要区别如下：

1. 线程安全性：StringBuffer是线程安全的，而StringBuilder不是。StringBuilder在多线程环境中使用可能会导致线程安全问题。
2. 性能：在单线程环境中，StringBuilder的性能通常比StringBuffer快。因为StringBuilder不执行同步操作，所以不会带来额外的系统消耗。但在多线程环境中，由于StringBuilder的非线程安全性，性能优势并不明显。
3. 操作：StringBuffer和StringBuilder都支持字符串操作，例如添加、删除、替换等。但两者在实现方式上略有不同，具体操作性能也有所差异。

总的来说，如果您在单线程环境中进行字符串操作，建议使用StringBuilder以提高性能；如果您在多线程环境中进行字符串操作，建议使用StringBuffer以保障线程安全。

## 9 == 和 equals 的区别

== 和 equals 的区别如下：

1. == 是比较运算符，用于比较两个值是否相等。（ == 比较的是地址）
2. equals 是一个类的方法，用于比较当前对象是否与另一个对象相等。
3. == 判断两个值是否相等，可以是基本类型的值，也可以是引用类型的值。
4. equals 比较的是对象内容是否一致。

总的来说，== 比较的是值是否相等，而 equals 比较的是对象内容是否相等。

## 10 hashCode和equals

hashCode和equals是Java中经常使用的两个方法，它们主要用于对象的比较和哈希值的计算。

hashCode方法返回对象的哈希码值，equals方法则用于判断两个对象是否相等。hashCode和equals的结合使用，可以让我们在Java中更有效地进行对象比较和哈希值计算。

在使用hashCode方法时，我们可以根据对象的属性计算出哈希值，并通过将哈希值与目标桶的哈希值进行比较，来判断对象是否应该被存储在相应的桶中。在查找对象时，我们可以先通过hashCode方法快速定位到目标桶，然后再通过equals方法判断目标对象是否与我们要找的对象相等。

然而，hashCode方法并不是完全可靠的，因为不同的对象有时可能计算出相同的哈希值。这时，如果我们将这些对象存储在同一个桶中，那么我们就无法通过equals方法判断它们是否相等。因此，为了保证equals方法的有效性，我们应该确保在计算哈希值时使用到的属性是唯一的，这样才能确保对象能够正确地进行比较和存储。

总的来说，hashCode和equals方法是Java中非常有用的两个方法，它们可以用于对象的比较、哈希值的计算等方面。在使用它们时，我们需要确保哈希值的唯一性和正确性，这样才能保证对象能够正确地进行比较和存储。