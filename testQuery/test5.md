# 改善SQL性能涉及哪些步骤
https://developer.aliyun.com/article/779151
对于MySQL层优化一般遵从五个原则：

<font color="#0070c0">1. 减少数据访问：设置合理的字段类型，启用压缩，通过索引访问等减少磁盘IO</font>
<font color="#0070c0">2. 返回更少的数据：只返回需要的字段和数据分页处理 减少磁盘io及网络io</font>
<font color="#0070c0">3. 减少交互次数：批量DML操作，函数存储等减少数据连接次数</font>
<font color="#0070c0">4. 减少服务器CPU开销：尽量减少数据库排序操作以及全表查询，减少cpu 内存占用</font>
<font color="#0070c0">5. 利用更多资源：使用表分区，可以增加并行操作，更大限度利用cpu资源</font>

总结到SQL优化中，就三点:
- **最大化利用索引；
- **尽可能避免全表扫描；
- **减少无效数据的查询；
# SpringSecurity与shiro的区别
https://blog.csdn.net/MinggeQingchun/article/details/126414384
1、Shiro比Spring Security更容易使用，也就是实现上简单一些，同时基本的授权认证Shiro也基本够用

2、Spring Security社区支持度更高（但是安装Spring Security很难），Spring社区支持力度和更新维护上有优势，同时和Spring这一套的结合较好

3、Shiro 功能强大、且 简单、灵活。是Apache 下的项目比较可靠，且不跟任何的框架或者容器绑定，可以独立运行
# SpringBoot如何解决跨域问题
1. 使用@CrossOrigin 注解实现**跨域**；
2. 通过配置文件实现**跨域**；
3. 通过CorsFilter 对象实现**跨域**；
4. 通过Response 对象实现**跨域**；
5. 通过实现ResponseBodyAdvice 实现**跨域**
# 说说RabbitMQ的routing路由模式
生产者将消息发送到direct交换器，在绑定队列和交换器的时候有一个路由key，生产者发送的消息会指定一个路由key，那么消息只会发送到相应key相同的队列，接着监听该队列的消费者消费消息。

也就是让消费者有选择性的接收消息。  
路由模式，是以路由规则为导向，引导消息存入符合规则的队列中。再由队列的消费者进行消费的。
# 如果Redis服务宕机，数据丢失怎么办
两种数据恢复和持久化的方案，分别是AOF和RDB。

AOF介绍了什么？如下：
1. AOF是写后日志，通过记录操作命令持久化数据。
2. 由于AOF是在命令执行之后记录日志，如果在写入磁盘之前服务器宕机，则会丢失数据；如果写入磁盘的时候突然阻塞，则会阻塞主线程；为了解决以上问题，AOF机制提供了三种写回的策略，每种策略都有不同的优缺点。
3. AOF日志文件过大怎么办？AOF通过fork一个子线程重写一个新的日志文件（共享主线程的内存，记录最新数据的写入命令），同时子线程重写，避免阻塞主线程。

RDB介绍了什么？如下：
1. RDB是内存快照，记录某一个时刻的内存数据，而不是操作命令。
2. Redis提供了两个命令，分别是save、bgsave来执行全量快照，这两个命令的区别则是save是在主线程执行，势必会阻塞主线程，bgsave是在fork一个子线程，共享内存。
3. RDB通过操作系统的写时复制技术，能够保证在执行快照的同时主线程能够修改快照。
4. 由于两次快照之间是存在间隔的，一旦服务器宕机，则会丢失两次间隔时刻的数据，Redis4.0开始使用AOF日志记录两次快照之间执行的命令（AOF和RDB混合使用）。
# mysql索引失效的情况有哪些，如何解决
1. 索引缺失：如果查询没有使用索引，可能会导致查询速度缓慢。解决方法是使用EXPLAIN关键字来检查查询是否使用了索引，如果没有，则可以添加适当的索引来优化查询。
2. 索引损坏：如果索引本身出现错误，可能会导致查询无法使用索引。解决方法是修复索引，可以使用REPAIR TABLE语句来修复索引。
3. 统计信息过时：MySQL使用统计信息来决定如何使用索引，如果统计信息过时，可能会导致索引无法被正确使用。解决方法是更新统计信息，可以使用ANALYZE TABLE语句来更新统计信息。
4. 查询语句不匹配：如果查询语句没有使用到创建的索引，那么这些索引可能不会加快查询速度。解决方法是检查查询语句是否与索引匹配，如果不匹配，则可以尝试调整查询语句或索引。
5. 锁竞争：如果多个查询同时竞争同一份数据，可能会导致锁竞争，从而影响查询性能。解决方法是减少竞争，可以使用不同的隔离级别、调整锁超时时间、使用分区表等方式来减少竞争。
6. 数据不均衡：如果表中的数据不均衡，例如某个列中的值分布不均匀，可能会导致索引无法发挥作用。解决方法是尝试合并或分区表，或者使用其他技术来均衡数据分布。
7. <font color="#ff0000">要解决MySQL索引失效的问题，首先需要找出问题所在，然后采取相应的解决方法。可以使用EXPLAIN关键字、统计信息和锁机制等相关工具和技术来帮助诊断和解决问题。</font>
# SpringBoot自动装配流程
1. 创建SpringApplication对象：在main方法中，首先需要创建SpringApplication对象，这是SpringBoot应用程序的入口点。
2. 配置元数据：SpringBoot从classpath上扫描和读取配置元数据，包括配置文件中的参数和属性。这些元数据将被用来配置SpringApplication对象。
3. 定义启动类：在启动类中，需要指定SpringApplication对象的名称，以及其他的配置信息。
4. 创建Spring容器：SpringApplication对象创建Spring容器，并将配置元数据注入到容器中。
5. 注册bean：Spring容器根据配置元数据，自动注册所有的bean，并将它们组成一个完整的Spring应用程序。
6. 处理MVC请求：最后，SpringBoot将处理所有的MVC请求，将它们映射到相应的bean方法上，并返回结果。
# 幂等性含义，说说哪些接口会出现幂等性
幂等性一般指同一个操作在同一个状态下执行多次，结果都是一样的，不会出现二义性。

以下是一些可能出现幂等性的接口：

1. GET请求：GET请求是一种只读请求，无论如何执行，都不会对系统状态进行修改，因此GET请求是幂等的。
2. 删除操作：如果删除操作只需要根据唯一标识删除某个实体，那么无论执行多少次，最终结果都是一样的，因此删除操作也是幂等的。
3. 确认订单操作：确认订单操作只需要根据订单编号或其他唯一标识确认订单状态，并不会对系统状态进行修改，因此确认订单操作也是幂等的。
4. 插入操作：如果插入操作需要满足唯一性约束，那么无论执行多少次，最终结果都是一样的，因此插入操作也是幂等的。
5. 修改操作：如果修改操作需要满足唯一性约束，那么无论执行多少次，最终结果都是一样的，因此修改操作也是幂等的。

总之，幂等性是一种非常基础的概念，需要我们在设计接口时考虑到，从而确保系统的正确性和可靠性。
# 说说分库分表如何实现
分库分表是一种常见的数据库拆分方式，可以将一个大型数据库拆分成多个小型数据库，以提高数据访问性能和数据库可扩展性。以下是一些常见的实现方式：

1. 数据库中间件：使用数据库中间件，如MyCat、TDDL等，进行分库分表管理。这些中间件可以将SQL请求路由到相应的数据库，并处理表的数据拆分和合并。
2. 客户端驱动：使用客户端驱动，如JDBC、MyBatis等，直接连接数据库进行操作。在客户端实现分库分表逻辑，将SQL请求路由到相应的数据库和表。
3. 代理模式：使用代理模式，如JPA、Hibernate等，通过代理将SQL请求转发到多个数据库，并处理表的数据拆分和合并。
4. 分布式缓存：使用分布式缓存，如Redis、Memcached等，将数据存储在缓存中，通过路由算法将请求路由到相应的缓存节点。
5. 数据库表自适应拆分：根据数据访问模式和数据量自适应拆分表，如将大表按照时间、ID等方式拆分成多个小表，提高并发性能。

无论哪种实现方式，都需要考虑数据的一致性、路由算法的合理性和性能优化等问题。同时，还需要结合具体的业务场景和数据访问特点进行选择和优化。
# 说一下你知道哪些索引，你如何创建索引的
一般我们创建索引会选择以下几种类型：

B树索引：B树索引是一种常用的索引，它能够快速定位到指定值，并且可以在磁盘上存储大量的数据。
哈希索引：哈希索引是一种基于哈希表实现的索引，它能够快速定位到指定值，但是需要考虑哈希冲突的问题。
全文索引：全文索引是一种针对文本数据的索引，它能够快速全文搜索文本数据。
空间索引：空间索引是一种针对空间数据（如地图、位置信息等）的索引，它能够快速定位到指定区域内的数据。

创建索引的方法根据不同的数据库管理系统有所不同，一般可以在SQL语句中通过CREATE INDEX来创建索引。例如，在MySQL中，可以使用以下SQL语句来创建一个名为index_name的B树索引：

sql
``CREATE INDEX index_name ON table_name (column_name);

其中，table_name是要创建索引的表名，column_name是要创建索引的列名。在创建索引时，需要注意不要过度索引，因为过多的索引会影响数据库性能。
# 说说springCloud的哪些组件，各个组件在什么情况下使用
Spring Cloud是一组工具集，可以帮助开发者快速构建分布式系统。它包含了多个组件，每个组件都可以单独使用，也可以组合起来使用。以下是一些常见的Spring Cloud组件：

1. Spring Cloud Netflix：提供了多个Netflix开发的微服务框架，如Ribbon、Eureka、Feign等。这些组件可以用于构建高可用的分布式系统。使用场景：需要实现服务的负载均衡和容错。
2. Spring Cloud Commons：提供了一些通用的工具集，如用于配置管理的Spring Cloud Config、用于消息传递的Spring Cloud Bus等。使用场景：需要实现服务的配置管理和消息传递。
3. Spring Cloud Data Flow：提供了一个分布式系统部署工具，可以用于部署和管理微服务。使用场景：需要实现服务的部署和管理。
4. Spring Cloud Security：提供了用于保护微服务的认证和授权功能。使用场景：需要实现微服务的认证和授权。
5. Spring Cloud Stream：提供了一个用于消息传递的微服务框架，可以使用常见的消息队列如Kafka、RabbitMQ等。使用场景：需要实现服务之间的消息传递。
6. Spring Cloud Task：提供了一个用于执行短期任务的微服务框架，如日志分析、数据处理等。使用场景：需要实现短期任务的执行。

使用Spring Cloud的每个组件的具体情况取决于项目的需求和开发者的个人偏好。例如，如果需要实现服务的负载均衡和容错，可以使用Spring Cloud Netflix的组件；如果需要实现服务的部署和管理，可以使用Spring Cloud Data Flow的组件。
# 可以说一下分布式事务吗
**分布式事务**指的是涉及分布式系统中多个独立的事务资源参与到一个全局的事务中。这些事务资源可能位于不同的节点上，因此需要一种机制来协调它们之间的操作。分布式事务问题的核心在于如何在分布式场景中保证多个节点数据的一致性。常见的解决方案包括<font color="#ff0000">强一致性和弱一致性</font>。强一致性要求系统写入什么，读出来的也会是什么，用户体验好，但实现起来往往对系统的性能影响大。而弱一致性则可以保证一定的数据更新速度，但可能不符合用户预期。在实际应用中，应尽可能从设计层面去避免分布式事务的问题，因为任何一种解决方案都会增加系统的复杂度。

Seata（Simple Extensible Autonomous Transaction Architecture）是一种分布式事务解决方案，它基于XA协议，并进行了优化和扩展。Seata实现了两阶段提交（2PC）和三阶段提交（3PC）协议，以解决分布式事务的问题。

在Seata中，分布式事务的协调者被称为TM（Transaction Manager），参与者被称为RM（Resource Manager）。Seata的分布式事务实现过程如下：

1. 启动Seata：首先，需要下载和初始化Seata环境。
2. 初始化数据表：在数据库中初始化Seata所需的数据表。
3. 添加配置：在应用程序中添加Seata的配置，包括事务超时时间、资源管理器类型和名称等。
4. 提交事务：在应用程序中调用Seata的事务提交方法，Seata会根据配置找到相应的RM和TM，并按照两阶段提交或三阶段提交协议执行事务。

总之，Seata通过XA协议和两阶段提交协议实现分布式事务，为应用程序提供了简单易用、可扩展和高效的分布式事务解决方案。
# redis分布式锁，项目如何使用的
使用Redis实现分布式锁可以通过以下步骤来实现：

1. 引入Redis客户端库：可以选择使用redisson或jedis等Redis客户端库。
2. 创建Redis连接池：在每个节点中，需要创建Redis连接池，以便于获取Redis连接。
3. 获取Redis连接：在需要获取锁的节点中，通过获取Redis连接来操作Redis数据。
4. 创建锁：使用Redis的setnx命令创建一个键值对，表示获取锁成功。
5. 释放锁：在完成操作后，使用Redis的del命令删除锁。
6. 
具体实现代码如下：
```java
// 创建Redis连接池  
JedisPool jedisPool = new JedisPool("localhost", 6379);    
// 获取Redis连接    
Jedis jedis = jedisPool.getResource();  
// 创建锁    
String lockName = "lockName";  
        long lockTimeout = 1000; // 锁超时时间，单位为毫秒    
String lockValue = "lockValue";  
        long acquireTime = System.currentTimeMillis();  
        int retryCount = 0;  
        while (true) {  
        String lockKey = generateLockKey(lockName, acquireTime);  
        String result = jedis.set(lockKey, lockValue, "NX", "EX", lockTimeout);  
        if (result.equals("OK")) {  
        // 获取锁成功    
break;  
        }  
        retryCount++;  
        if (retryCount > LOCK_RETRY_COUNT) {  
        throw new RuntimeException("获取锁失败，超时时间到达");  
        }  
        // 重试    
Thread.sleep(100);  
        }  
// 执行操作  // ...    
// 释放锁    
jedis.del(lockKey);
```
在上面的代码中，使用了一个while循环来不断尝试获取锁，如果获取成功则跳出循环，否则继续重试。同时，通过设置retryCount变量来记录重试次数，防止死锁的情况发生。

需要注意的是，在使用Redis实现分布式锁时，需要考虑锁的超时时间设置，以及锁的键值对的命名规则等。同时，还需要保证不同节点中的时间同步，以避免锁的超时时间计算不一致的问题。

# 秒杀加了什么锁，怎么用的
# sql慢查询如何解决
# redis集群如何保证数据的一致性
# redis集群，有哪些实现方式
# 对锁了解吗？Redisson
# mysql隔离级别？默认隔离级别？